{
  "name": "continuation-local-storage",
  "version": "1.1.0",
  "description": "userland implementation of https://github.com/joyent/node/issues/5243",
  "main": "context.js",
  "directories": {
    "test": "test"
  },
  "scripts": {
    "test": "tap test/*.tap.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/othiym23/node-continuation-local-storage.git"
  },
  "keywords": [
    "threading",
    "shared",
    "context",
    "domains",
    "tracing",
    "logging"
  ],
  "author": {
    "name": "Forrest L Norvell",
    "email": "ogd@aoaioxxysz.net"
  },
  "contributors": [
    {
      "name": "Tim Caswell",
      "email": "tim@creationix.com"
    },
    {
      "name": "Forrest L Norvell",
      "email": "ogd@aoaioxxysz.net"
    }
  ],
  "license": "BSD",
  "devDependencies": {
    "tap": "~0.4.2"
  },
  "readme": "# Continuation-Local Storage\n\n    Stability: 1 - Experimental\n\nContinuation-local storage provides a mechanism similar to thread-local storage\nin threaded programming, with closures wrapped around portions of a\ncontinuation chain taking the place of mutable cells bound to thread data\nstructures. Contexts are created on namespaces and can be be nested.\n\nEvery namespace is created with a default context. The currently active\ncontext on a namespace is available via `namespace.active`.\n\n```javascript\nvar cls = require('contination-local-storage');\n\nvar writer = cls.createNamespace('writer');\nwriter.set('value', 0);\n\nfunction requestHandler() {\n  writer.run(function (outer) {\n    // writer.get('value') returns 0\n    // outer.value is 0\n    writer.set('value', 1);\n    // writer.get('value') returns 1\n    // outer.value is 1\n    process.nextTick(function () {\n      // writer.get('value') returns 1\n      // outer.value is 1\n      writer.run(function (inner) {\n        // writer.get('value') returns 1\n        // outer.value is 1\n        // inner.value is 1\n        writer.set('value', 2);\n        // writer.get('value') returns 2\n        // outer.value is 1\n        // inner.value is 2\n      });\n    });\n  });\n\n  setTimeout(function () {\n    // runs with the default context, because nested contexts have ended\n    console.log(writer.get('value')); // prints 0\n  }, 1000);\n}\n```\n\n## cls.createNamespace(name)\n\n* return: {Namespace}\n\nEach application that wants to use continuation-local attributes should create\nits own namespace. Reading from (or, more significantly, writing to) namespaces\nthat don't belong to you should be considered a faux pas.\n\n## cls.getNamespace(name)\n\n* return: {Namespace}\n\nLook up an existing namespace.\n\n## process.namespaces\n\n* return: dictionary of {Namespace} objects\n\nSet of available namespaces.\n\n## Class: Namespace\n\nApplication-specific namespaces provide access to continuation-local\nattributes, and may have specialized behavior on a per-namespace basis (custom\nnesting behavior). Once the execution of a handler chain begins, creating new\ncontexts and changing local values should be considered mutating the value of a\ngiven attribute on that particular continuation chain.\n\n### namespace.active\n\nReturns the currently active context on a namespace.\n\n### namespace.set(key, value)\n\nSet a value on the current continuation context. Shorthand for\n`namespace.active.set(key, value)`.\n\nReturns the value.\n\n### namespace.get(key)\n\nLook up a value on the current continuation context. Recursively searches from\nthe innermost to outermost nested continuation context for a value associated\nwith a given key.\n\n### namespace.run(continuation)\n\nCreate a new scope to which attributes can be bound or mutated.  Run the\ncontinuation in this new scope (passing in the new context into the\ncontinuation).  It also returns the context that just exited in case you want\nto read data from it.\n\n### namespace.bind(callback, [context])\n\nBind a function to the specified continuation context. Works analagously to\n`Function.bind()` or `domain.bind()`.  If context is omitted, it will default to\nthe currently active context in the namespace.\n\n## context\n\nA context is just a plain object that inherits from it's parent context.\n\n## Rationale\n\nThe domains mechanism is a useful tool for adding context to errors\nraised in asynchronous call chains (or, if you like living dangerously /\ntempting the wrath of @isaacs, to recover from errors without restarting\nyour services). It also almost serves the purposes of developers\nwho want to annotate async call chains with metadata or extra state\n(examples: logging, tracing / profiling, generic instrumentation),\nbut due to the needs of error-handling, it doesn't quite generalize\nenough to be truly useful in this regard. There are modules that allow\ndevelopers to do similar things when they have full control over their\nstacks ([CrabDude/trycatch](https://github.com/CrabDude/trycatch) and\n[Gozala/reducers](https://github.com/Gozala/reducers), among many\nothers), but none of these modules are a good fit for developers writing\ntooling meant to be dropped transparently into user code.\n\nSee also [joyent/node#3733](https://github.com/joyent/issues/3733).\n\nHere is a sketch at what the user-visible API might look like. My\noriginal attempt at this used a slightly modified version of the domains\nAPI with some special-purpose logic for dealing with nested contexts,\nbut allowing multiple distinct namespaces is actually simpler and trades\nmemory for execution time. It also makes it possible to special-case\nbehavior for specific namespaces (i.e. my hope would be that domains\nwould just become a specialized namespace, and `_tickDomainCallback`\nand `_nextDomainTick` would be all that would be required to deal with\nnamespaces), although that isn't included here.\n\nHere's an example of how the API might be used:\n\n```javascript\nvar cls = require('continuation-local-storage');\n\n// multiple contexts in use\nvar tracer = cls.createNamespace('tracer');\n\nfunction Trace(harvester) {\n  this.harvester = harvester;\n}\n\nTrace.prototype.runHandler = function (callback) {\n  var trace = tracer.run(callback);\n  this.harvester.emit('finished', trace.transaction);\n};\n\nTrace.prototype.annotateState = function (name, value) {\n  tracer.set(name, value);\n};\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/othiym23/node-continuation-local-storage/issues"
  },
  "_id": "continuation-local-storage@1.1.0",
  "_from": "continuation-local-storage@~1.1"
}
